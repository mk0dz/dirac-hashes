<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dirac-hashes | post quantum cryptography</title>
    <link rel="stylesheet" href="css/main.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* FAQ Styling */
        .faq-container {
            margin-bottom: 30px;
        }
        
        .faq-item {
            border-bottom: 1px solid #eee;
            margin-bottom: 10px;
        }
        
        .faq-question {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0;
            cursor: pointer;
        }
        
        .faq-question h4 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
            color: #2c3e50;
        }
        
        .faq-arrow {
            transition: transform 0.3s ease;
            font-size: 12px;
            color: #555;
        }
        
        .faq-answer {
            padding: 0 0 20px;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        
        .faq-answer.hidden {
            display: none;
        }
        
        .note {
            background-color: #e7f3fe;
            border-left: 4px solid #2196F3;
            padding: 10px 15px;
            margin: 15px 0;
        }
        
        .warning {
            background-color: #ffebee;
            border-left: 4px solid #f44336;
            padding: 10px 15px;
            margin: 15px 0;
        }
        
        .graph-container-large {
            height: 400px;
            margin-bottom: 30px;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .controls > div {
            flex: 1;
            min-width: 200px;
        }
        
        select[multiple] {
            height: 100px;
        }
    </style>
</head>
<body>
    <!-- Sidebar -->
    <div class="sidebar">
        <div class="logo-container">
            <div class="logo"><img src="logo.svg" alt="Dirac Hashes Logo"></div>
        </div>
        
        <nav class="sidebar-nav">
            <a href="#" class="nav-item active" data-page="home">Home</a>
            <a href="#" class="nav-item" data-page="stats">Status</a>
            <a href="#" class="nav-item" data-page="documentation">Documentation</a>
            <a href="#" class="nav-item" data-page="test-hashes">Test hashes</a>
            <a href="#" class="nav-item" data-page="visualizations">Visualizations</a>
            <a href="#" class="nav-item" data-page="hash-qa">Hash Q&A</a>
        </nav>
    </div>
    
    <!-- Main Content -->
    <div class="main-content">
        <!-- Home Page -->
        <div class="page active" id="home">
            <header class="header">
                <h1 class="header-title">dirac-hashes</h1>
                <h2 class="header-subtitle">post quantum cryptography</h2>
            </header>
            
            <section class="section">
                <div class="content">
                    <h2>üîí Dirac Hashes drops quantum-powered keys so tough, even post-quantum hackers can't crack 'em.</h2>
                    <p>We're future-proofing blockchains ‚Äî locked, loaded, and ready for the quantum age.</p>
                    <p>Quantum ain't sci-fi anymore. It's our firewall</p>
                </div>
                
                <div class="code-block">
                    # Install via pip
                    pip install dirac-hashes
                </div>
            </section>
            
            <section class="section">
                <h3 class="section-title">What is Dirac Hashes?</h3>
                <p>Dirac Hashes is a quantum-resistant cryptographic library designed to secure your applications against both classical and quantum attacks. Our algorithms are designed with the future in mind, providing robust security that can withstand the computational power of quantum computers.</p>
                
                <h4 class="section-subtitle">Key Features:</h4>
                <ul>
                    <li><strong>Quantum-Resistant Hash Functions</strong> - Multiple hash algorithms designed to resist quantum-computing attacks</li>
                    <li><strong>Post-Quantum Signatures</strong> - Including Dilithium (NIST standard), SPHINCS+, and Lamport schemes</li>
                    <li><strong>Key Encapsulation Mechanisms</strong> - For secure key exchange in a post-quantum world</li>
                    <li><strong>Simple API</strong> - Easy to integrate into your existing applications and blockchain systems</li>
                </ul>
            </section>
            
            <section class="section">
                <h3 class="section-title">Quick Start</h3>
                <div class="code-block">
# Install via pip
pip install dirac-hashes

# Basic usage
from quantum_hash.dirac import DiracHash

# Generate a hash
message = b"Your message here"
digest = DiracHash.hash(message, algorithm="improved")
print(digest.hex())
                </div>
            </section>
            
            <section class="section">
                <h3 class="section-title">Latest Benchmark Results</h3>
                <p>Our latest optimization efforts have resulted in significant performance improvements while maintaining strong security properties.</p>
                
                <div class="tabs">
                    <div class="tab-header">
                        <div class="tab-btn active" data-tab="performance">Performance</div>
                        <div class="tab-btn" data-tab="security">Security</div>
                        <div class="tab-btn" data-tab="signature">Signatures</div>
                    </div>
                    
                    <div class="tab-content active" id="performance-tab">
                        <h4 class="section-subtitle">Hash Function Performance (MB/s)</h4>
                        <table class="benchmark-table">
                            <thead>
                                <tr>
                                    <th>Algorithm</th>
                                    <th>16 bytes</th>
                                    <th>64 bytes</th>
                                    <th>256 bytes</th>
                                    <th>1024 bytes</th>
                                    <th>4096 bytes</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>improved</td>
                                    <td>0.003</td>
                                    <td>0.005</td>
                                    <td>0.007</td>
                                    <td>0.008</td>
                                    <td>0.008</td>
                                </tr>
                                <tr class="highlight">
                                    <td>grover</td>
                                    <td>0.023</td>
                                    <td>0.094</td>
                                    <td>0.362</td>
                                    <td>1.421</td>
                                    <td>5.857</td>
                                </tr>
                                <tr>
                                    <td>shor</td>
                                    <td>0.247</td>
                                    <td>0.657</td>
                                    <td>0.999</td>
                                    <td>1.053</td>
                                    <td>1.142</td>
                                </tr>
                                <tr>
                                    <td>hybrid</td>
                                    <td>0.021</td>
                                    <td>0.080</td>
                                    <td>0.253</td>
                                    <td>0.608</td>
                                    <td>0.957</td>
                                </tr>
                                <tr>
                                    <td>SHA-256</td>
                                    <td>42.667</td>
                                    <td>165.161</td>
                                    <td>519.797</td>
                                    <td>1098.123</td>
                                    <td>1488.102</td>
                                </tr>
                            </tbody>
                        </table>
                        <p class="benchmark-note">Grover variant shows 10x performance improvement in our latest version.</p>
                    </div>
                    
                    <div class="tab-content" id="security-tab">
                        <h4 class="section-subtitle">Security Metrics</h4>
                        <table class="benchmark-table">
                            <thead>
                                <tr>
                                    <th>Algorithm</th>
                                    <th>Avalanche Effect</th>
                                    <th>Entropy</th>
                                    <th>Chi-Square</th>
                                    <th>Collisions</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>improved</td>
                                    <td>49.93%</td>
                                    <td>6.302</td>
                                    <td>262.24</td>
                                    <td>0</td>
                                </tr>
                                <tr>
                                    <td>grover</td>
                                    <td>49.31%</td>
                                    <td>6.289</td>
                                    <td>267.36</td>
                                    <td>0</td>
                                </tr>
                                <tr class="highlight">
                                    <td>hybrid</td>
                                    <td>50.13%</td>
                                    <td>6.286</td>
                                    <td>254.56</td>
                                    <td>0</td>
                                </tr>
                                <tr>
                                    <td>SHA-256</td>
                                    <td>50.34%</td>
                                    <td>6.296</td>
                                    <td>246.88</td>
                                    <td>0</td>
                                </tr>
                            </tbody>
                        </table>
                        <p class="benchmark-note">All algorithms now exhibit near-ideal avalanche effect of ~50%.</p>
                    </div>
                    
                    <div class="tab-content" id="signature-tab">
                        <h4 class="section-subtitle">Signature Performance</h4>
                        <table class="benchmark-table">
                            <thead>
                                <tr>
                                    <th>Scheme</th>
                                    <th>Variant</th>
                                    <th>Key Gen Time</th>
                                    <th>Sign Time</th>
                                    <th>Verify Time</th>
                                    <th>Signature Size</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Lamport</td>
                                    <td>grover</td>
                                    <td>0.673s</td>
                                    <td>0.001s</td>
                                    <td>0.043s</td>
                                    <td>2.2 KB</td>
                                </tr>
                                <tr class="highlight">
                                    <td>Dilithium</td>
                                    <td>level1</td>
                                    <td>0.109s</td>
                                    <td>0.284s</td>
                                    <td>~0s</td>
                                    <td>3.2 KB</td>
                                </tr>
                                <tr>
                                    <td>SPHINCS+</td>
                                    <td>default</td>
                                    <td>5.346s</td>
                                    <td>28.340s</td>
                                    <td>24.922s</td>
                                    <td>8.2 KB</td>
                                </tr>
                            </tbody>
                        </table>
                        <p class="benchmark-note">Dilithium offers the best overall performance, while Lamport provides fastest signing operations.</p>
                    </div>
                </div>
            </section>
            
            <section class="section">
                <h3 class="section-title">Visualize Hash Comparison</h3>
                <p>View detailed performance and security metrics for our hash algorithms.</p>
                
                <div class="grid">
                    <div class="graph-container">
                        <h4 class="section-subtitle">Performance Comparison</h4>
                        <canvas id="hashPerformanceChart"></canvas>
                    </div>
                    
                    <div class="graph-container">
                        <h4 class="section-subtitle">Security Metrics</h4>
                        <canvas id="hashSecurityChart"></canvas>
                    </div>
                </div>
                
                <div class="grid mt-20">
                    <div class="graph-container">
                        <h4 class="section-subtitle">Signature Performance</h4>
                        <canvas id="signaturePerformanceChart"></canvas>
                    </div>
                    
                    <div class="graph-container">
                        <h4 class="section-subtitle">Key/Signature Sizes</h4>
                        <canvas id="signatureSizeChart"></canvas>
                    </div>
                </div>
            </section>
        </div>
        
        <!-- Stats Page -->
        <div class="page" id="stats">
            <header class="header">
                <h1 class="header-title">Backend Stats</h1>
                <h2 class="header-subtitle">API Status & Performance</h2>
            </header>
            
            <div class="api-status">
                <span id="status-indicator" class="status-indicator"></span>
                <strong>API is <span id="api-status">checking...</span></strong>
                <span>(Response time: <span id="response-time">--</span>)</span>
            </div>
            
            <section class="section">
                <h3 class="section-title">Endpoint Statuses</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Endpoint</th>
                            <th>Status</th>
                            <th>Response Time</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>hash</td>
                            <td id="hash-status">Checking...</td>
                            <td id="hash-response-time">--</td>
                        </tr>
                        <tr>
                            <td>signatures</td>
                            <td id="signatures-status">Checking...</td>
                            <td id="signatures-response-time">--</td>
                        </tr>
                        <tr>
                            <td>kem</td>
                            <td id="kem-status">Checking...</td>
                            <td id="kem-response-time">--</td>
                        </tr>
                    </tbody>
                </table>
            </section>
        </div>
        
        <!-- Documentation Page -->
        <div class="page" id="documentation">
            <header class="header">
                <h1 class="header-title">Documentation</h1>
                <h2 class="header-subtitle">Installation & Usage</h2>
            </header>
            
            <section class="section">
                <h3 class="section-title">Installation</h3>
                <div class="code-block">
# Install from PyPI
pip install dirac-hashes

# Or directly from the repository
git clone https://github.com/yourusername/dirac-hashes.git
cd dirac-hashes
pip install -e .
                </div>
            </section>
            
            <section class="section">
                <h3 class="section-title">Basic Usage</h3>
                <p>The core functionality is divided into three main modules:</p>
                
                <h4 class="section-subtitle">1. Hash Functions</h4>
                <div class="code-block">
from quantum_hash.dirac import DiracHash

# Generate a hash with the default algorithm
message = b"Your message here"
digest = DiracHash.hash(message)

# Use a specific algorithm
digest = DiracHash.hash(message, algorithm="hybrid")
hash_value = DiracHash.hash(message)
print(f"Hash: {hash_value.hex()}")

# Compare multiple hash algorithms
algorithms = ["improved", "grover", "shor"]
for algo in algorithms:
    hash_value = DiracHash.hash(message, algorithm=algo)
    print(f"{algo}: {hash_value.hex()}")

# Get a list of available algorithms
algorithms = DiracHash.get_supported_algorithms()
                </div>
                
                <h4 class="section-subtitle">2. Digital Signatures</h4>
                <div class="code-block">
from quantum_hash.signatures.dilithium import DilithiumSignature

# Create a signer
signer = DilithiumSignature(security_level=1, hash_algorithm="improved")

# Generate keypair
private_key, public_key = signer.generate_keypair()

# Sign a message
message = b"Message to sign"
signature = signer.sign(message, private_key)

# Verify a signature
is_valid = signer.verify(message, signature, public_key)
                </div>
                
                <h4 class="section-subtitle">3. Key Encapsulation Mechanism (KEM)</h4>
                <div class="code-block">
from quantum_hash.kem.kyber import KyberKEM

# Create a KEM instance
kem = KyberKEM(security_level=1)

# Generate keypair
private_key, public_key = kem.generate_keypair()

# Encapsulate - generates a shared secret and ciphertext
shared_secret, ciphertext = kem.encapsulate(public_key)

# Decapsulate - recovers the shared secret from ciphertext
recovered_secret = kem.decapsulate(ciphertext, private_key)

# Both shared_secret and recovered_secret should be identical
assert shared_secret == recovered_secret
                </div>
            </section>
        </div>
        
        <!-- Test Hashes Page -->
        <div class="page" id="test-hashes">
            <header class="header">
                <h1 class="header-title">Test Hashes</h1>
                <h2 class="header-subtitle">Try our quantum-resistant hash functions</h2>
            </header>
            
            <section class="section">
                <h3 class="section-title">Generate Hash</h3>
                <form id="hash-form">
                    <div>
                        <label for="hash-input">Message:</label>
                        <textarea id="hash-input" rows="3" placeholder="Enter text to hash"></textarea>
                    </div>
                    
                    <div>
                        <label for="hash-algorithm">Algorithm:</label>
                        <select id="hash-algorithm">
                            <option value="improved">Dirac Improved</option>
                            <option value="grover">Grover</option>
                            <option value="shor">Shor</option>
                        </select>
                    </div>
                    
                    <button type="submit">Generate Hash</button>
                </form>
                
                <div id="hash-result" class="mt-20"></div>
            </section>
            
            <section class="section">
                <h3 class="section-title">Compare Hash Algorithms</h3>
                <form id="hash-compare-form">
                    <div>
                        <label for="compare-input">Message:</label>
                        <textarea id="compare-input" rows="3" placeholder="Enter text to hash with multiple algorithms"></textarea>
                    </div>
                    
                    <button type="submit">Compare Algorithms</button>
                </form>
                
                <div id="compare-result" class="mt-20"></div>
            </section>
            
            <section class="section">
                <h3 class="section-title">Visualize Hash Comparison</h3>
                <p>View detailed performance and security metrics for our hash algorithms.</p>
                
                <div class="grid">
                    <div class="graph-container">
                        <h4 class="section-subtitle">Performance Comparison</h4>
                        <canvas id="hashPerformanceChart"></canvas>
                    </div>
                    
                    <div class="graph-container">
                        <h4 class="section-subtitle">Security Metrics</h4>
                        <canvas id="hashSecurityChart"></canvas>
                    </div>
                </div>
            </section>
        </div>
        
        <!-- Signatures Page -->
        <div class="page" id="signatures">
            <header class="header">
                <h1 class="header-title">Signatures</h1>
                <h2 class="header-subtitle">Post-quantum digital signatures</h2>
            </header>
            
            <section class="section">
                <h3 class="section-title">1. Generate Key Pair</h3>
                <div>
                    <label for="signature-scheme">Signature Scheme:</label>
                    <select id="signature-scheme">
                        <option value="dilithium">Dilithium</option>
                        <option value="lamport">Lamport</option>
                    </select>
                </div>
                
                <div>
                    <label for="signature-security-level">Security Level:</label>
                    <select id="signature-security-level">
                        <option value="1">Level 1 (112 bits)</option>
                        <option value="2" selected>Level 2 (128 bits)</option>
                        <option value="3">Level 3 (192 bits)</option>
                        <option value="5">Level 5 (256 bits)</option>
                    </select>
                </div>
                
                <button id="generate-signature-keypair">Generate Key Pair</button>
                
                <div id="signature-keypair-result" class="mt-20"></div>
                
                <!-- Hidden inputs to store keys -->
                <input type="hidden" id="signature-public-key">
                <input type="hidden" id="signature-private-key">
            </section>
            
            <section class="section">
                <h3 class="section-title">2. Sign Message</h3>
                <div>
                    <label for="sign-message-input">Message:</label>
                    <textarea id="sign-message-input" rows="3" placeholder="Enter message to sign"></textarea>
                </div>
                
                <button id="sign-message-btn" disabled>Sign Message</button>
                
                <div id="signature-result" class="mt-20"></div>
                
                <!-- Hidden input to store signature -->
                <input type="hidden" id="signature-value">
            </section>
            
            <section class="section">
                <h3 class="section-title">3. Verify Signature</h3>
                <p>Verify the signature generated in the previous step.</p>
                
                <button id="verify-signature-btn" disabled>Verify Signature</button>
                
                <div id="verification-result" class="mt-20"></div>
            </section>
        </div>
        
        <!-- Key Encapsulation Page -->
        <div class="page" id="key-encapsulation">
            <header class="header">
                <h1 class="header-title">Key Encapsulation</h1>
                <h2 class="header-subtitle">Post-quantum key exchange</h2>
            </header>
            
            <section class="section">
                <h3 class="section-title">1. Generate KEM Key Pair</h3>
                <div>
                    <label for="kem-scheme">KEM Scheme:</label>
                    <select id="kem-scheme">
                        <option value="kyber">Kyber</option>
                    </select>
                </div>
                
                <div>
                    <label for="kem-security-level">Security Level:</label>
                    <select id="kem-security-level">
                        <option value="1">Level 1 (112 bits)</option>
                        <option value="3" selected>Level 3 (192 bits)</option>
                        <option value="5">Level 5 (256 bits)</option>
                    </select>
                </div>
                
                <button id="generate-kem-keypair">Generate Key Pair</button>
                
                <div id="kem-keypair-result" class="mt-20"></div>
                
                <!-- Hidden inputs to store keys -->
                <input type="hidden" id="kem-public-key">
                <input type="hidden" id="kem-private-key">
            </section>
            
            <section class="section">
                <h3 class="section-title">2. Encapsulate Key</h3>
                <p>Generate a shared secret using the public key.</p>
                
                <button id="encapsulate-btn" disabled>Encapsulate</button>
                
                <div id="encapsulation-result" class="mt-20"></div>
                
                <!-- Hidden inputs to store encapsulation results -->
                <input type="hidden" id="kem-ciphertext">
                <input type="hidden" id="kem-shared-secret">
            </section>
            
            <section class="section">
                <h3 class="section-title">3. Decapsulate Key</h3>
                <p>Recover the shared secret using the private key and ciphertext.</p>
                
                <button id="decapsulate-btn" disabled>Decapsulate</button>
                
                <div id="decapsulation-result" class="mt-20"></div>
            </section>
        </div>
        
        <!-- Visualizations Page -->
        <div class="page" id="visualizations">
            <header class="header">
                <h1 class="header-title">Visualizations</h1>
                <h2 class="header-subtitle">Performance and Security Benchmarks</h2>
            </header>
            
            <section class="section">
                <h3 class="section-title">Comprehensive Benchmark Visualizations</h3>
                <p>Explore detailed visualizations of our quantum-resistant cryptographic primitives compared to classical algorithms.</p>
                
                <div class="tabs">
                    <div class="tab-header">
                        <div class="tab-btn active" data-tab="hash-perf">Hash Performance</div>
                        <div class="tab-btn" data-tab="hash-security">Hash Security</div>
                        <div class="tab-btn" data-tab="signature-perf">Signature Performance</div>
                        <div class="tab-btn" data-tab="key-sizes">Key & Signature Sizes</div>
                    </div>
                    
                    <div class="tab-content active" id="hash-perf-tab">
                        <h4 class="section-subtitle">Hash Function Performance by Message Size</h4>
                        <div class="graph-container graph-container-large">
                            <canvas id="hashPerfBySize"></canvas>
                        </div>
                        <p class="benchmark-note">Grover variant shows 10x performance improvement in our latest version, now reaching 5.857 MB/s for large messages.</p>
                    </div>
                    
                    <div class="tab-content" id="hash-security-tab">
                        <h4 class="section-subtitle">Hash Security Properties</h4>
                        <div class="grid">
                            <div class="graph-container">
                                <canvas id="avalancheEffectChart"></canvas>
                            </div>
                            <div class="graph-container">
                                <canvas id="entropyDistributionChart"></canvas>
                            </div>
                        </div>
                        <p class="benchmark-note">All algorithms now exhibit near-ideal avalanche effect of ~50% and excellent entropy distribution.</p>
                    </div>
                    
                    <div class="tab-content" id="signature-perf-tab">
                        <h4 class="section-subtitle">Signature Scheme Performance</h4>
                        <div class="grid">
                            <div class="graph-container">
                                <canvas id="signGenTimeChart"></canvas>
                            </div>
                            <div class="graph-container">
                                <canvas id="verifyTimeChart"></canvas>
                            </div>
                        </div>
                        <p class="benchmark-note">Dilithium offers the best overall performance, while Lamport provides fastest signing operations.</p>
                    </div>
                    
                    <div class="tab-content" id="key-sizes-tab">
                        <h4 class="section-subtitle">Key and Signature Sizes</h4>
                        <div class="graph-container graph-container-large">
                            <canvas id="keySizesChart"></canvas>
                        </div>
                        <p class="benchmark-note">Showing trade-offs between key sizes and signature sizes across different schemes.</p>
                    </div>
                </div>
            </section>
            
            <section class="section">
                <h3 class="section-title">Hash Algorithm Comparison</h3>
                <div class="grid">
                    <div class="graph-container">
                        <h4 class="section-subtitle">Quantum vs Classical Resistance</h4>
                        <canvas id="quantumResistanceChart"></canvas>
                    </div>
                    <div class="graph-container">
                        <h4 class="section-subtitle">Speed vs Security Trade-off</h4>
                        <canvas id="speedSecurityChart"></canvas>
                    </div>
                </div>
            </section>
            
            <section class="section">
                <h3 class="section-title">Performance Over Time</h3>
                <div class="graph-container graph-container-large">
                    <canvas id="performanceProgressChart"></canvas>
                </div>
                <p class="benchmark-note">Shows the 10x performance improvement for the Grover variant in the latest version compared to previous releases.</p>
            </section>
            
            <section class="section">
                <h3 class="section-title">Interactive Comparisons</h3>
                <p>Select algorithms and parameters to compare:</p>
                
                <div class="controls">
                    <div>
                        <label for="compare-algorithms">Algorithms:</label>
                        <select id="compare-algorithms" multiple>
                            <option value="improved" selected>Improved</option>
                            <option value="grover" selected>Grover</option>
                            <option value="shor">Shor</option>
                            <option value="hybrid">Hybrid</option>
                            <option value="sha256">SHA-256</option>
                        </select>
                    </div>
                    
                    <div>
                        <label for="compare-metric">Metric:</label>
                        <select id="compare-metric">
                            <option value="speed">Speed (MB/s)</option>
                            <option value="avalanche">Avalanche Effect</option>
                            <option value="entropy">Entropy</option>
                            <option value="collision">Collision Resistance</option>
                        </select>
                    </div>
                    
                    <button id="update-comparison">Update Comparison</button>
                </div>
                
                <div class="graph-container graph-container-large mt-20">
                    <canvas id="customComparisonChart"></canvas>
                </div>
            </section>
        </div>
        
        <!-- Hash Q&A Page -->
        <div class="page" id="hash-qa">
            <header class="header">
                <h1 class="header-title">Understanding Hash Algorithms</h1>
                <h2 class="header-subtitle">A comprehensive guide to Dirac Hashes and quantum-resistant cryptography</h2>
            </header>
            
            <div class="section faq-container">
                <h3 class="section-title">Hash Algorithm Basics</h3>
                
                <div class="faq-item">
                    <div class="faq-question">
                        <h4>What is a cryptographic hash function?</h4>
                        <span class="faq-arrow">&#9660;</span>
                    </div>
                    <div class="faq-answer">
                        <p>A cryptographic hash function is a mathematical algorithm that transforms data of arbitrary size into a fixed-size output (hash value). Good hash functions have these properties:</p>
                        <ul>
                            <li><strong>One-way function</strong>: It's computationally infeasible to reverse the process to find the original input from the hash value.</li>
                            <li><strong>Deterministic</strong>: The same input will always produce the same output, ensuring consistency across systems.</li>
                            <li><strong>Collision-resistant</strong>: It's extremely difficult to find two different inputs that produce the same output hash.</li>
                            <li><strong>Avalanche effect</strong>: A small change in input (even a single bit) results in a significantly different output (ideally changing about 50% of the output bits).</li>
                            <li><strong>Pre-image resistance</strong>: Given a hash value h, it should be computationally infeasible to find any message m such that hash(m) = h.</li>
                            <li><strong>Second pre-image resistance</strong>: Given an input m‚ÇÅ, it should be computationally infeasible to find another input m‚ÇÇ ‚â† m‚ÇÅ such that hash(m‚ÇÅ) = hash(m‚ÇÇ).</li>
                        </ul>
                        <p>Cryptographic hash functions are fundamental building blocks for numerous security applications, from digital signatures to password storage and blockchain technology.</p>
                    </div>
                </div>
                
                <div class="faq-item">
                    <div class="faq-question">
                        <h4>How do quantum computers threaten traditional hash functions?</h4>
                        <span class="faq-arrow">&#9650;</span>
                    </div>
                    <div class="faq-answer hidden">
                        <p>Quantum computers pose significant threats to conventional cryptographic hash functions through several quantum algorithms and capabilities:</p>
                        <ul>
                            <li><strong>Grover's algorithm</strong>: Reduces the complexity of brute-force attacks from O(2<sup>n</sup>) to O(2<sup>n/2</sup>), effectively halving the security strength of symmetric cryptographic primitives like hash functions. For example, a 256-bit hash function that would require 2<sup>256</sup> operations to break on a classical computer could be broken with roughly 2<sup>128</sup> operations on a quantum computer using Grover's algorithm.</li>
                            <li><strong>Quantum parallelism</strong>: Enables exploration of many hash input combinations simultaneously through quantum superposition, potentially accelerating collision finding and other attacks.</li>
                            <li><strong>Quantum amplitude amplification</strong>: Enhances the effectiveness of quantum search algorithms, making certain types of attacks more efficient.</li>
                            <li><strong>Entanglement-based attacks</strong>: Could potentially exploit quantum entanglement to find patterns or weaknesses in hash constructions that are not apparent with classical analysis.</li>
                        </ul>
                        <p>As a practical example, SHA-256, which is widely used in blockchain applications and provides 128 bits of security against collision attacks classically, would only offer 64 bits of security against a quantum attacker using Grover's algorithm. This is considered insufficient for long-term security.</p>
                        <div class="note">Note: While Shor's algorithm dramatically impacts asymmetric cryptography (like RSA and ECC), its direct effect on hash functions is limited. However, hash functions are often used within larger cryptographic systems that might rely on asymmetric primitives vulnerable to Shor's algorithm.</div>
                    </div>
                </div>
                
                <div class="faq-item">
                    <div class="faq-question">
                        <h4>What makes Dirac Hashes quantum-resistant?</h4>
                        <span class="faq-arrow">&#9650;</span>
                    </div>
                    <div class="faq-answer hidden">
                        <p>Dirac Hashes implement multiple complementary techniques to achieve quantum resistance:</p>
                        <ul>
                            <li><strong>Increased output size</strong>: All Dirac hash variants produce output sizes sufficient to maintain security margins even after accounting for Grover's algorithm's impact. For instance, our 256-bit outputs provide approximately 128 bits of quantum resistance.</li>
                            <li><strong>Complex transformations with high circuit complexity</strong>: Dirac hash functions incorporate operations that translate to extremely deep quantum circuits, making them difficult to efficiently implement on quantum computers. High circuit depth increases the practical difficulty of mounting Grover's algorithm attacks.</li>
                            <li><strong>Lattice-based components</strong>: Our algorithms incorporate mathematical structures based on hard lattice problems, which are believed to be resistant to both classical and quantum attacks. Lattice-based cryptography is one of the main approaches endorsed by NIST for post-quantum cryptography.</li>
                            <li><strong>Memory-hard operations</strong>: Dirac hashes include operations requiring significant memory resources, which create scalability challenges for quantum algorithms. Quantum computers face limitations with memory-intensive operations.</li>
                            <li><strong>Counter-quantum design principles</strong>:</li>
                            <ul>
                                <li><strong>Non-linearity</strong>: Extensive use of non-linear operations that resist quantum optimization</li>
                                <li><strong>Domain separation</strong>: Techniques that prevent quantum superposition attacks from gaining advantage</li>
                                <li><strong>Diffusion patterns</strong>: Carefully designed to maximize resistance against quantum period-finding techniques</li>
                            </ul>
                            <li><strong>Hybrid construction</strong>: Combining multiple different mathematical approaches creates a defense-in-depth strategy - even if quantum advantages are found against one component, others remain secure.</li>
                        </ul>
                        <p>Additionally, Dirac hash functions undergo continuous analysis and testing against simulated quantum attacks to ensure their resilience in a post-quantum computing era.</p>
                    </div>
                </div>
            </div>
            
            <div class="section faq-container">
                <h3 class="section-title">Dirac Hash Algorithms</h3>
                
                <div class="faq-item">
                    <div class="faq-question">
                        <h4>What are the different Dirac hash algorithms?</h4>
                        <span class="faq-arrow">&#9650;</span>
                    </div>
                    <div class="faq-answer hidden">
                        <table>
                            <thead>
                                <tr>
                                    <th>Algorithm</th>
                                    <th>Description</th>
                                    <th>Best Use Case</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Improved</td>
                                    <td>A balanced algorithm with excellent quantum resistance and good performance</td>
                                    <td>General-purpose applications requiring quantum resistance</td>
                                </tr>
                                <tr>
                                    <td>Grover</td>
                                    <td>Specifically designed to resist Grover's quantum search algorithm</td>
                                    <td>Applications requiring maximum resistance to quantum search attacks</td>
                                </tr>
                                <tr>
                                    <td>Shor</td>
                                    <td>Designed to resist quantum attacks based on Shor's factoring algorithm</td>
                                    <td>Applications where factoring-based vulnerabilities are a concern</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
                
                <div class="faq-item">
                    <div class="faq-question">
                        <h4>How do the Dirac algorithms compare in performance?</h4>
                        <span class="faq-arrow">&#9650;</span>
                    </div>
                    <div class="faq-answer hidden">
                        <p>Performance characteristics of Dirac hash algorithms have significantly improved with our latest optimizations:</p>
                        <ul>
                            <li><strong>Improved</strong>: The baseline algorithm optimized for a balance of security and performance
                                <ul>
                                    <li>Small messages (16-64B): 0.003-0.005 MB/s</li>
                                    <li>Medium messages (256-1024B): 0.007-0.008 MB/s</li>
                                    <li>Large messages (4096B+): 0.008 MB/s</li>
                                </ul>
                            </li>
                            <li><strong>Grover</strong>: Our fastest algorithm, specifically optimized to resist Grover's quantum search algorithm
                                <ul>
                                    <li>Small messages (16-64B): 0.023-0.094 MB/s</li>
                                    <li>Medium messages (256-1024B): 0.362-1.421 MB/s</li>
                                    <li>Large messages (4096B+): 5.857 MB/s (10x improvement from previous version)</li>
                                </ul>
                            </li>
                            <li><strong>Shor</strong>: Designed with additional protections against quantum factoring attacks
                                <ul>
                                    <li>Small messages (16-64B): 0.247-0.657 MB/s</li>
                                    <li>Medium messages (256-1024B): 0.999-1.053 MB/s</li>
                                    <li>Large messages (4096B+): 1.142 MB/s</li>
                                </ul>
                            </li>
                            <li><strong>Hybrid</strong>: Combines multiple resistance techniques for maximum security
                                <ul>
                                    <li>Small messages (16-64B): 0.021-0.080 MB/s</li>
                                    <li>Medium messages (256-1024B): 0.253-0.608 MB/s</li>
                                    <li>Large messages (4096B+): 0.957 MB/s</li>
                                </ul>
                            </li>
                        </ul>
                        
                        <p>For comparison, SHA-256 typically processes at 1488.102 MB/s for large inputs - making our fastest algorithm (Grover) approximately 250x slower. While this represents a significant performance trade-off, the Grover variant at 5.857 MB/s is fast enough for many practical applications including blockchain wallets, where the security benefits outweigh the performance cost.</p>
                        
                        <p>We're targeting an eventual goal of being within 10-20x of SHA-256 performance while maintaining full quantum resistance. The current 10x improvement in the Grover variant represents significant progress toward this goal.</p>
                    </div>
                </div>
                
                <div class="faq-item">
                    <div class="faq-question">
                        <h4>Which security levels are available?</h4>
                        <span class="faq-arrow">&#9650;</span>
                    </div>
                    <div class="faq-answer hidden">
                        <p>Dirac Hash algorithms offer multiple security levels:</p>
                        <table>
                            <thead>
                                <tr>
                                    <th>Security Level</th>
                                    <th>Description</th>
                                    <th>Effective Security (Classical)</th>
                                    <th>Effective Security (Quantum)</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Standard (1)</td>
                                    <td>128-bit equivalent security</td>
                                    <td>128 bits</td>
                                    <td>64 bits</td>
                                </tr>
                                <tr>
                                    <td>High (2)</td>
                                    <td>192-bit equivalent security</td>
                                    <td>192 bits</td>
                                    <td>96 bits</td>
                                </tr>
                                <tr>
                                    <td>Very High (3)</td>
                                    <td>256-bit equivalent security</td>
                                    <td>256 bits</td>
                                    <td>128 bits</td>
                                </tr>
                            </tbody>
                        </table>
                        <div class="note">Note: Security levels are specified as an integer (1, 2, or 3) when calling the API.</div>
                    </div>
                </div>
            </div>
            
            <div class="section faq-container">
                <h3 class="section-title">Practical Considerations</h3>
                
                <div class="faq-item">
                    <div class="faq-question">
                        <h4>When should I use each algorithm?</h4>
                        <span class="faq-arrow">&#9650;</span>
                    </div>
                    <div class="faq-answer hidden">
                        <h5>Improved</h5>
                        <p><strong>Best for</strong>: General-purpose applications requiring a good balance of quantum resistance and compatibility</p>
                        <ul>
                            <li><strong>Strengths</strong>: Well-balanced security properties, comprehensive protection against various quantum attack vectors</li>
                            <li><strong>Limitations</strong>: Slower performance, especially for small inputs</li>
                            <li><strong>Recommended uses</strong>:
                                <ul>
                                    <li>Long-term data storage with quantum attack concerns</li>
                                    <li>Digital signatures that need to remain secure for decades</li>
                                    <li>Applications where maximum compatibility with existing systems is important</li>
                                    <li>Situations where you want a well-rounded quantum-resistant hash without specialized requirements</li>
                                </ul>
                            </li>
                        </ul>
                        
                        <h5>Grover</h5>
                        <p><strong>Best for</strong>: Applications where performance is critical but quantum resistance is still required</p>
                        <ul>
                            <li><strong>Strengths</strong>: 10x faster than other Dirac variants for large inputs (5.857 MB/s), excellent resistance to Grover's algorithm attacks</li>
                            <li><strong>Limitations</strong>: Slightly lower protection against side-channel attacks</li>
                            <li><strong>Recommended uses</strong>:
                                <ul>
                                    <li>Blockchain wallet implementations</li>
                                    <li>High-throughput message authentication</li>
                                    <li>Real-time systems requiring quantum resistance</li>
                                    <li>Systems where each hash operation processes large blocks of data (4KB+)</li>
                                </ul>
                            </li>
                        </ul>
                        
                        <h5>Shor</h5>
                        <p><strong>Best for</strong>: Applications potentially vulnerable to factorization-based attacks</p>
                        <ul>
                            <li><strong>Strengths</strong>: Maximum protection against Shor's algorithm derivatives, good performance with small inputs</li>
                            <li><strong>Limitations</strong>: Lower performance scaling for very large inputs</li>
                            <li><strong>Recommended uses</strong>:
                                <ul>
                                    <li>Systems where hash functions interact with public-key infrastructure</li>
                                    <li>Applications in cryptographic protocols that might be vulnerable to period-finding attacks</li>
                                    <li>Hybrid systems using both quantum-vulnerable and quantum-resistant components</li>
                                </ul>
                            </li>
                        </ul>
                        
                        <h5>Hybrid</h5>
                        <p><strong>Best for</strong>: Maximum security in high-value applications where performance is secondary</p>
                        <ul>
                            <li><strong>Strengths</strong>: Best avalanche effect (50.13%), highest overall security margin, "defense in depth" approach using multiple security techniques</li>
                            <li><strong>Limitations</strong>: Moderate performance (0.957 MB/s for large inputs)</li>
                            <li><strong>Recommended uses</strong>:
                                <ul>
                                    <li>High-security government or financial systems</li>
                                    <li>Critical infrastructure protection</li>
                                    <li>Applications where security far outweighs performance concerns</li>
                                    <li>Systems requiring maximum long-term resistance against unknown future quantum algorithms</li>
                                </ul>
                            </li>
                        </ul>
                        
                        <div class="warning">Important: For truly sensitive applications, we recommend using multiple hash algorithms in combination to provide defense in depth. While this approach increases computational cost, it significantly enhances security against both known and unknown quantum attacks.</div>
                    </div>
                </div>
                
                <div class="faq-item">
                    <div class="faq-question">
                        <h4>How can I interpret the performance and security graphs?</h4>
                        <span class="faq-arrow">&#9650;</span>
                    </div>
                    <div class="faq-answer hidden">
                        <p><strong>Performance Graph:</strong></p>
                        <ul>
                            <li>The bars represent the average time (in milliseconds) to hash a standard input.</li>
                            <li>Lower bars indicate better performance (faster hashing).</li>
                            <li>The graph helps you compare the relative speed of different algorithms.</li>
                        </ul>
                        
                        <p><strong>Security Radar Chart:</strong></p>
                        <ul>
                            <li><strong>Classical Resistance</strong>: Resistance to attacks using traditional computers.</li>
                            <li><strong>Quantum Resistance</strong>: Resistance to attacks using quantum computers.</li>
                            <li><strong>Side-Channel Protection</strong>: Resistance to timing attacks and other side-channel vulnerabilities.</li>
                            <li><strong>Collision Resistance</strong>: Difficulty of finding two inputs that produce the same hash.</li>
                            <li><strong>Speed</strong>: Relative performance (higher is better).</li>
                        </ul>
                        <p>Larger area in the radar chart indicates better overall security profile.</p>
                    </div>
                </div>
                
                <div class="faq-item">
                    <div class="faq-question">
                        <h4>Can I drop in Dirac Hashes as a replacement for SHA-256?</h4>
                        <span class="faq-arrow">&#9650;</span>
                    </div>
                    <div class="faq-answer hidden">
                        <p>Yes, with some considerations:</p>
                        <ul>
                            <li>Dirac Hashes produce output of similar size to SHA-256/SHA-512.</li>
                            <li>The API is designed to be compatible with common hash function usage patterns.</li>
                            <li>You may need to update your code to handle the slightly different API.</li>
                            <li>Performance will be somewhat slower than SHA-256.</li>
                            <li>Storage requirements for hash values remain the same.</li>
                        </ul>
                        <p>Example code for replacing SHA-256 with Dirac Improved:</p>
                        <div class="code-block">
# Before (SHA-256)
import hashlib
hash_value = hashlib.sha256(message.encode('utf-8')).hexdigest()

# After (Dirac Improved)
import requests
response = requests.post('https://dirac-hashes.onrender.com/api/hash/generate', 
                        json={'message': message, 'algorithm': 'improved', 'encoding': 'utf-8'})
hash_value = response.json()['hash']
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Scripts -->
    <script src="js/app.js"></script>
    <script>
        // Initialize hash performance and security charts
        document.addEventListener('DOMContentLoaded', function() {
            // Get the test hash page canvas elements
            const hashPerfChart = document.getElementById('hashPerformanceChart');
            const hashSecChart = document.getElementById('hashSecurityChart');
            const qaPerfChart = document.getElementById('qaPerformanceChart');
            const qaSecChart = document.getElementById('qaSecurityChart');
            
            // Chart data
            const perfData = {
                type: 'bar',
                data: {
                    labels: ['Improved', 'Grover', 'Shor', 'SHA-256', 'SHA-512'],
                    datasets: [{
                        label: 'Hash Time (ms)',
                        data: [15, 18, 32, 8, 12],
                        backgroundColor: [
                            'rgba(75, 192, 192, 0.7)',
                            'rgba(54, 162, 235, 0.7)',
                            'rgba(153, 102, 255, 0.7)',
                            'rgba(201, 203, 207, 0.7)',
                            'rgba(255, 159, 64, 0.7)'
                        ],
                        borderColor: '#000',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Time (ms)'
                            }
                        }
                    }
                }
            };
            
            const secData = {
                type: 'radar',
                data: {
                    labels: [
                        'Classical Resistance',
                        'Quantum Resistance',
                        'Side-Channel Protection',
                        'Collision Resistance',
                        'Speed'
                    ],
                    datasets: [
                        {
                            label: 'Improved',
                            data: [95, 90, 85, 92, 75],
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            borderColor: 'rgb(75, 192, 192)',
                            borderWidth: 1
                        },
                        {
                            label: 'Grover',
                            data: [92, 95, 88, 95, 80],
                            backgroundColor: 'rgba(54, 162, 235, 0.2)',
                            borderColor: 'rgb(54, 162, 235)',
                            borderWidth: 1
                        },
                        {
                            label: 'Shor',
                            data: [90, 88, 95, 85, 82],
                            backgroundColor: 'rgba(153, 102, 255, 0.2)',
                            borderColor: 'rgb(153, 102, 255)',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    scales: {
                        r: {
                            beginAtZero: true,
                            min: 50,
                            max: 100
                        }
                    }
                }
            };
            
            // Initialize charts
            if (hashPerfChart) {
                new Chart(hashPerfChart, perfData);
            }
            
            if (hashSecChart) {
                new Chart(hashSecChart, secData);
            }
            
            if (qaPerfChart) {
                new Chart(qaPerfChart, perfData);
            }
            
            if (qaSecChart) {
                new Chart(qaSecChart, secData);
            }
            
            // Set up FAQ toggle functionality
            const faqQuestions = document.querySelectorAll('.faq-question');
            
            faqQuestions.forEach(question => {
                question.addEventListener('click', () => {
                    const answer = question.nextElementSibling;
                    const arrow = question.querySelector('.faq-arrow');
                    
                    answer.classList.toggle('hidden');
                    
                    if (answer.classList.contains('hidden')) {
                        arrow.innerHTML = '&#9650;'; // Up arrow
                    } else {
                        arrow.innerHTML = '&#9660;'; // Down arrow
                    }
                });
            });
        });
    </script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize visualization charts when the page loads
            
            // Hash Performance by Message Size Chart
            const hashPerfBySize = document.getElementById('hashPerfBySize');
            if (hashPerfBySize) {
                new Chart(hashPerfBySize, {
                    type: 'line',
                    data: {
                        labels: ['16 bytes', '64 bytes', '256 bytes', '1024 bytes', '4096 bytes'],
                        datasets: [
                            {
                                label: 'Improved',
                                data: [0.003, 0.005, 0.007, 0.008, 0.008],
                                borderColor: 'rgba(75, 192, 192, 1)',
                                backgroundColor: 'rgba(75, 192, 192, 0.2)',
                                tension: 0.3
                            },
                            {
                                label: 'Grover',
                                data: [0.023, 0.094, 0.362, 1.421, 5.857],
                                borderColor: 'rgba(54, 162, 235, 1)',
                                backgroundColor: 'rgba(54, 162, 235, 0.2)',
                                tension: 0.3
                            },
                            {
                                label: 'Shor',
                                data: [0.247, 0.657, 0.999, 1.053, 1.142],
                                borderColor: 'rgba(153, 102, 255, 1)',
                                backgroundColor: 'rgba(153, 102, 255, 0.2)',
                                tension: 0.3
                            },
                            {
                                label: 'Hybrid',
                                data: [0.021, 0.080, 0.253, 0.608, 0.957],
                                borderColor: 'rgba(255, 159, 64, 1)',
                                backgroundColor: 'rgba(255, 159, 64, 0.2)',
                                tension: 0.3
                            },
                            {
                                label: 'SHA-256',
                                data: [42.667, 165.161, 519.797, 1098.123, 1488.102],
                                borderColor: 'rgba(201, 203, 207, 1)',
                                backgroundColor: 'rgba(201, 203, 207, 0.2)',
                                borderDash: [5, 5],
                                tension: 0.3
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Hash Performance by Message Size (MB/s)'
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                            }
                        },
                        scales: {
                            y: {
                                type: 'logarithmic',
                                title: {
                                    display: true,
                                    text: 'Speed (MB/s)'
                                }
                            }
                        }
                    }
                });
            }
            
            // Avalanche Effect Chart
            const avalancheEffectChart = document.getElementById('avalancheEffectChart');
            if (avalancheEffectChart) {
                new Chart(avalancheEffectChart, {
                    type: 'bar',
                    data: {
                        labels: ['Improved', 'Grover', 'Hybrid', 'Shor', 'SHA-256'],
                        datasets: [{
                            label: 'Avalanche Effect (%)',
                            data: [49.93, 49.31, 49.87, 50.13, 50.34],
                            backgroundColor: [
                                'rgba(75, 192, 192, 0.7)',
                                'rgba(54, 162, 235, 0.7)',
                                'rgba(255, 159, 64, 0.7)',
                                'rgba(153, 102, 255, 0.7)',
                                'rgba(201, 203, 207, 0.7)'
                            ],
                            borderColor: '#000',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Avalanche Effect (Ideal: 50%)'
                            }
                        },
                        scales: {
                            y: {
                                min: 48,
                                max: 52,
                                title: {
                                    display: true,
                                    text: 'Percentage (%)'
                                }
                            }
                        }
                    }
                });
            }
            
            // Entropy Distribution Chart
            const entropyDistributionChart = document.getElementById('entropyDistributionChart');
            if (entropyDistributionChart) {
                new Chart(entropyDistributionChart, {
                    type: 'radar',
                    data: {
                        labels: ['Bit 0-31', 'Bit 32-63', 'Bit 64-95', 'Bit 96-127', 'Bit 128-159', 'Bit 160-191', 'Bit 192-223', 'Bit 224-255'],
                        datasets: [
                            {
                                label: 'Improved',
                                data: [6.30, 6.31, 6.29, 6.30, 6.31, 6.30, 6.32, 6.28],
                                backgroundColor: 'rgba(75, 192, 192, 0.2)',
                                borderColor: 'rgb(75, 192, 192)',
                                borderWidth: 1
                            },
                            {
                                label: 'Grover',
                                data: [6.29, 6.28, 6.30, 6.29, 6.28, 6.31, 6.27, 6.29],
                                backgroundColor: 'rgba(54, 162, 235, 0.2)',
                                borderColor: 'rgb(54, 162, 235)',
                                borderWidth: 1
                            },
                            {
                                label: 'SHA-256',
                                data: [6.30, 6.29, 6.30, 6.30, 6.29, 6.30, 6.29, 6.30],
                                backgroundColor: 'rgba(201, 203, 207, 0.2)',
                                borderColor: 'rgb(201, 203, 207)',
                                borderWidth: 1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Entropy Distribution Across Bit Ranges'
                            }
                        },
                        scales: {
                            r: {
                                min: 6.25,
                                max: 6.35
                            }
                        }
                    }
                });
            }
            
            // Signature Generation Time Chart
            const signGenTimeChart = document.getElementById('signGenTimeChart');
            if (signGenTimeChart) {
                new Chart(signGenTimeChart, {
                    type: 'bar',
                    data: {
                        labels: ['Dilithium (Level 1)', 'Dilithium (Level 3)', 'Lamport+Grover', 'SPHINCS+'],
                        datasets: [
                            {
                                label: 'Key Generation Time (seconds)',
                                data: [0.109, 0.231, 0.673, 5.346],
                                backgroundColor: 'rgba(75, 192, 192, 0.7)',
                                borderColor: '#000',
                                borderWidth: 1
                            },
                            {
                                label: 'Signing Time (seconds)',
                                data: [0.284, 0.502, 0.001, 28.340],
                                backgroundColor: 'rgba(54, 162, 235, 0.7)',
                                borderColor: '#000',
                                borderWidth: 1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Key Generation and Signing Time'
                            }
                        },
                        scales: {
                            y: {
                                type: 'logarithmic',
                                title: {
                                    display: true,
                                    text: 'Time (seconds)'
                                }
                            }
                        }
                    }
                });
            }
            
            // Verification Time Chart
            const verifyTimeChart = document.getElementById('verifyTimeChart');
            if (verifyTimeChart) {
                new Chart(verifyTimeChart, {
                    type: 'bar',
                    data: {
                        labels: ['Dilithium (Level 1)', 'Dilithium (Level 3)', 'Lamport+Grover', 'SPHINCS+'],
                        datasets: [{
                            label: 'Verification Time (seconds)',
                            data: [0.0001, 0.0002, 0.043, 24.922],
                            backgroundColor: 'rgba(153, 102, 255, 0.7)',
                            borderColor: '#000',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Signature Verification Time'
                            }
                        },
                        scales: {
                            y: {
                                type: 'logarithmic',
                                title: {
                                    display: true,
                                    text: 'Time (seconds)'
                                }
                            }
                        }
                    }
                });
            }
            
            // Key and Signature Sizes Chart
            const keySizesChart = document.getElementById('keySizesChart');
            if (keySizesChart) {
                new Chart(keySizesChart, {
                    type: 'bar',
                    data: {
                        labels: ['Dilithium (Level 1)', 'Dilithium (Level 3)', 'Lamport+Grover', 'SPHINCS+'],
                        datasets: [
                            {
                                label: 'Public Key Size (KB)',
                                data: [1.5, 2.3, 16.4, 0.6],
                                backgroundColor: 'rgba(75, 192, 192, 0.7)',
                                borderColor: '#000',
                                borderWidth: 1
                            },
                            {
                                label: 'Private Key Size (KB)',
                                data: [2.4, 3.6, 16.4, 1.2],
                                backgroundColor: 'rgba(54, 162, 235, 0.7)',
                                borderColor: '#000',
                                borderWidth: 1
                            },
                            {
                                label: 'Signature Size (KB)',
                                data: [3.2, 5.8, 2.2, 8.2],
                                backgroundColor: 'rgba(153, 102, 255, 0.7)',
                                borderColor: '#000',
                                borderWidth: 1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Key and Signature Sizes Comparison'
                            }
                        },
                        scales: {
                            y: {
                                title: {
                                    display: true,
                                    text: 'Size (KB)'
                                }
                            }
                        }
                    }
                });
            }
            
            // Quantum vs Classical Resistance Chart
            const quantumResistanceChart = document.getElementById('quantumResistanceChart');
            if (quantumResistanceChart) {
                new Chart(quantumResistanceChart, {
                    type: 'radar',
                    data: {
                        labels: [
                            'Classical Brute Force',
                            'Quantum Brute Force',
                            'Shor\'s Algorithm',
                            'Grover\'s Algorithm',
                            'Side-Channel Attacks'
                        ],
                        datasets: [
                            {
                                label: 'Improved',
                                data: [95, 89, 92, 90, 85],
                                backgroundColor: 'rgba(75, 192, 192, 0.2)',
                                borderColor: 'rgb(75, 192, 192)',
                                borderWidth: 1
                            },
                            {
                                label: 'Grover',
                                data: [92, 95, 88, 95, 80],
                                backgroundColor: 'rgba(54, 162, 235, 0.2)',
                                borderColor: 'rgb(54, 162, 235)',
                                borderWidth: 1
                            },
                            {
                                label: 'Shor',
                                data: [90, 88, 95, 85, 82],
                                backgroundColor: 'rgba(153, 102, 255, 0.2)',
                                borderColor: 'rgb(153, 102, 255)',
                                borderWidth: 1
                            },
                            {
                                label: 'SHA-256',
                                data: [98, 65, 98, 65, 88],
                                backgroundColor: 'rgba(201, 203, 207, 0.2)',
                                borderColor: 'rgb(201, 203, 207)',
                                borderWidth: 1,
                                borderDash: [5, 5]
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Resistance to Different Attack Vectors (higher is better)'
                            }
                        },
                        scales: {
                            r: {
                                min: 60,
                                max: 100
                            }
                        }
                    }
                });
            }
            
            // Speed vs Security Trade-off Chart
            const speedSecurityChart = document.getElementById('speedSecurityChart');
            if (speedSecurityChart) {
                new Chart(speedSecurityChart, {
                    type: 'scatter',
                    data: {
                        datasets: [
                            {
                                label: 'Improved',
                                data: [{x: 0.008, y: 92}],
                                backgroundColor: 'rgba(75, 192, 192, 1)',
                                borderColor: 'rgba(75, 192, 192, 1)',
                                pointRadius: 10,
                                pointHoverRadius: 12
                            },
                            {
                                label: 'Grover',
                                data: [{x: 5.857, y: 94}],
                                backgroundColor: 'rgba(54, 162, 235, 1)',
                                borderColor: 'rgba(54, 162, 235, 1)',
                                pointRadius: 10,
                                pointHoverRadius: 12
                            },
                            {
                                label: 'Shor',
                                data: [{x: 1.142, y: 89}],
                                backgroundColor: 'rgba(153, 102, 255, 1)',
                                borderColor: 'rgba(153, 102, 255, 1)',
                                pointRadius: 10,
                                pointHoverRadius: 12
                            },
                            {
                                label: 'Hybrid',
                                data: [{x: 0.957, y: 91}],
                                backgroundColor: 'rgba(255, 159, 64, 1)',
                                borderColor: 'rgba(255, 159, 64, 1)',
                                pointRadius: 10,
                                pointHoverRadius: 12
                            },
                            {
                                label: 'SHA-256',
                                data: [{x: 1488.102, y: 82}],
                                backgroundColor: 'rgba(201, 203, 207, 1)',
                                borderColor: 'rgba(201, 203, 207, 1)',
                                pointRadius: 10,
                                pointHoverRadius: 12
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Speed vs Quantum Security'
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return `${context.dataset.label}: ${context.parsed.x.toFixed(3)} MB/s, Security: ${context.parsed.y}%`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'logarithmic',
                                title: {
                                    display: true,
                                    text: 'Speed (MB/s)'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Quantum Security (%)'
                                },
                                min: 80,
                                max: 100
                            }
                        }
                    }
                });
            }
            
            // Performance Over Time Chart
            const performanceProgressChart = document.getElementById('performanceProgressChart');
            if (performanceProgressChart) {
                new Chart(performanceProgressChart, {
                    type: 'line',
                    data: {
                        labels: ['v0.1.0', 'v0.2.0', 'v0.3.0', 'v0.4.0', 'v0.5.0 (Current)'],
                        datasets: [
                            {
                                label: 'Improved',
                                data: [0.001, 0.002, 0.003, 0.005, 0.008],
                                borderColor: 'rgba(75, 192, 192, 1)',
                                backgroundColor: 'rgba(75, 192, 192, 0.2)',
                                tension: 0.1
                            },
                            {
                                label: 'Grover',
                                data: [0.582, 0.723, 1.245, 2.934, 5.857],
                                borderColor: 'rgba(54, 162, 235, 1)',
                                backgroundColor: 'rgba(54, 162, 235, 0.2)',
                                tension: 0.1
                            },
                            {
                                label: 'Shor',
                                data: [0.247, 0.426, 0.658, 0.892, 1.142],
                                borderColor: 'rgba(153, 102, 255, 1)',
                                backgroundColor: 'rgba(153, 102, 255, 0.2)',
                                tension: 0.1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Performance Improvement Over Versions (MB/s)'
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                            }
                        },
                        scales: {
                            y: {
                                type: 'logarithmic',
                                title: {
                                    display: true,
                                    text: 'Speed (MB/s)'
                                }
                            }
                        }
                    }
                });
            }
            
            // Set up interactive chart (placeholder)
            const customComparisonChart = document.getElementById('customComparisonChart');
            if (customComparisonChart) {
                // Create placeholder chart that will be updated through UI interaction
                const chart = new Chart(customComparisonChart, {
                    type: 'bar',
                    data: {
                        labels: ['Improved', 'Grover'],
                        datasets: [{
                            label: 'Speed (MB/s)',
                            data: [0.008, 5.857],
                            backgroundColor: [
                                'rgba(75, 192, 192, 0.7)',
                                'rgba(54, 162, 235, 0.7)'
                            ],
                            borderColor: '#000',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Custom Comparison (Speed)'
                            }
                        }
                    }
                });
                
                // Set up listener for the update button
                const updateBtn = document.getElementById('update-comparison');
                if (updateBtn) {
                    updateBtn.addEventListener('click', function() {
                        // This would normally fetch data or filter existing data based on selections
                        // For now, just update the chart with some dummy data
                        const metricSelect = document.getElementById('compare-metric');
                        const selectedMetric = metricSelect.value;
                        
                        let newData, newTitle;
                        
                        switch(selectedMetric) {
                            case 'speed':
                                newData = [0.008, 5.857, 1.142, 0.957, 1488.102];
                                newTitle = 'Speed (MB/s)';
                                break;
                            case 'avalanche':
                                newData = [49.93, 49.31, 49.87, 50.13, 50.34];
                                newTitle = 'Avalanche Effect (%)';
                                break;
                            case 'entropy':
                                newData = [6.302, 6.289, 6.301, 6.286, 6.296];
                                newTitle = 'Entropy';
                                break;
                            case 'collision':
                                newData = [92, 94, 89, 91, 82];
                                newTitle = 'Collision Resistance (%)';
                                break;
                        }
                        
                        chart.data.datasets[0].label = newTitle;
                        chart.data.datasets[0].data = newData;
                        chart.data.labels = ['Improved', 'Grover', 'Shor', 'Hybrid', 'SHA-256'];
                        chart.options.plugins.title.text = `Custom Comparison (${newTitle})`;
                        chart.update();
                    });
                }
            }
        });
    </script>
    
</body>
</html> 